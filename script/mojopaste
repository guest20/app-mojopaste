#!/usr/bin/env perl
use Mojolicious::Lite;

use Mojo::Util qw(encode decode spurt slurp);
use File::Path ();
use File::Spec;
use Mojo::File 'path';
use Mojo::JSON 'true';

plugin 'config' if $ENV{MOJO_CONFIG};

my $WANT_MAGICK = app->config('enable_images') // $ENV{PASTE_ENABLE_IMAGES};
my ($HAS_MAGICK, $HAS_NO_MAGICK) = 
  eval "use Image::Info; 1" ? (1, undef) : (0, $@);

app->log->warn(
  # scale images down 
  # replicate images
  # type detection from Image::Info might be enough
  # perhaps clean up the json response from .txt on images
  # the use above likely ruins later checks
  (not $WANT_MAGICK) ? "Image support disabled." :
  ($HAS_MAGICK       ? "Image support enabled."  
                     : ("Image support requested but you don't have Image::Magick",
                        " so I'll ignore your request.", $HAS_NO_MAGICK )
));

app->defaults(
  layout        => 'mojopaste',
  enable_charts => app->config('enable_charts') // $ENV{PASTE_ENABLE_CHARTS},
  enable_images => $WANT_MAGICK && $HAS_MAGICK,
  enable_fetching=> $ENV{PASTE_ENABLE_FETCH} || 0,
  embed         => 'description,graph,heading,nav',
  error         => '',
  paste         => '',
  placeholder   => 'Enter your text here or select an image above and then press the "Save" button above.',
  title         => 'Mojopaste',
  source_url    => 'https://metacpan.org/pod/App::mojopaste#DESCRIPTION',
  source_title  => 'Powered by Mojopaste',
);

my $paste_dir = app->config('paste_dir') || $ENV{PASTE_DIR} || 'paste';
-d $paste_dir or File::Path::mkpath($paste_dir) or die "mkpath $paste_dir: $!";

# All the urls pastes should be replicated to, including my own root:
my $paste_peers = exists $ENV{MOJO_CONFIG}
                    ? app->config('paste_peers')    || []
                    : [split ' ', $ENV{PASTE_PEERS} || '']
                    ;
my @peer_urls = map Mojo::URL->new($_), @$paste_peers;

my @image_extensions   = (qw[ png       jpg        gif       tiff ]);
my @allowed_image_types= (qw[ image/png image/jpeg image/gif image/tiff ]);

helper read_paste => sub { my ($c, $id, $cb) = @_;
  my $paste;
  eval { $paste = decode('UTF-8', path($paste_dir, $id)->slurp) ;1 }
  or do { return $c->cb( $@, undef ) };
  return $c->$cb(undef, $paste)
};
helper write_paste => sub { my ($c, $id, $paste, $cb) = @_;
  eval  { path($paste_dir, $id)->spurt(encode('UTF-8', $paste)) }
  or do { return $c->$cb($@, undef); };
  return $c->$cb(undef, $paste);
};


get '/' =>  sub {
  my $c = shift;
  return unless my $id = $c->param('edit');
  return $c->delay(
    sub { $c->read_paste($id => shift->begin) },
    sub {
      my ($delay, $err, $paste) = @_;
      return $c->reply->not_found  if $err or !$paste;
      return $c->param(paste => $paste)->render;
    },
  );
  },
  'pastebin';

# put /
post '/' => sub {
  my $c = shift;

  return $c->render(text => 'File is too big.', status => 200)
    if $c->req->is_limit_exceeded;

  # uploads:
  my $up = $c->param('image_upload');
  if ( app->defaults('enable_images') and defined $up and $up->size ) {
      my $size = $up->size;
      my $name = $up->filename;

      my $id = Mojo::Util::sha1_sum($up->slurp);
      my $image_path = File::Spec->catfile($paste_dir, $id);

      # At this point the file has already been uploaded, so I don't save
      # any bandwidth by declining, but whatever.
      return $c->redirect_to( "/" . $id . "?already_existed=1") if -e $image_path;

      # This is where you'd replicate this thing to the others.

      $up->move_to( $image_path ); # would be nicer if we didn't just ->slurp
      app->log->info( "Received $size byte file $name as $id");
      return $c->redirect_to( "/" . $id );
  }

  my $paste = $c->param('paste') || '';

  # downloads:
  if ( $c->param('body_is_url') and $c->stash('enable_fetching') ) {

    my $url = Mojo::URL->new($paste);
    app->log->warn("Fetching '$url' ");
    # TODO: rate limints per domain / client-ip.
    #       log the url some place
    $c->ua->get( $url, sub { my ($ua,$tx) = @_;
        my $content = $tx->res->body;
        my $id = Mojo::Util::sha1_sum($content);
        my $save_path = File::Spec->catfile($paste_dir, $id); # maybe not an image
        spurt($content, $save_path);

        # This is where you'd replicate this thing to the others.
        $c->redirect_to('show', paste_id => $id);
        return $c->rendered(302);
    });
    return $c->render_later;
    
  }

  return $c->render('pastebin', placeholder => 'You neeed to enter some characters!', status => 400)
    unless $paste =~ /\w/;

  my $id = Mojo::Util::sha1_sum( encode 'UTF-8', $paste );
  $c->delay(
    sub {
        my $delay = shift;

        if (not @peer_urls) { 
            # 0 peers listed, just write locally.
            return $c->write_paste($id => $paste, $delay->begin(1,1))
        }

        # With peers listed, we replicate to everyone.
        # Which means I have to replicate to myself too:
        $delay->begin->(undef,undef); # offsets

        # replicate
        $_->path( "$id/replicate" )
            for my @post_to = map $_->clone, @peer_urls;


        $c->app->log->info( sprintf "Replicating %s to %s instance(s).", $id, scalar @post_to);
        $c->ua->put( $_, form => { paste => $paste, }, $delay->begin )
            for @post_to;
    },
    sub {
      my ($delay, $local_err, @remote_tx) = @_;

      $c->app->log->info( sprintf "Replicate to [%s]: %s %s",
            $_->req->url,
            $_->success ? ($_->res->code,           $_->res->body) 
                        : ($_->error->{code} // '', $_->error->{message} // '' )
      ) for @remote_tx;

      die $local_err if $local_err;

      $c->redirect_to('show', paste_id => $id);
    },
  );
  };

put '/:paste_id/replicate', sub {
  my $c = shift;

  $c->helpers->reply->not_found # I am alone, this is a trick.
      unless @$paste_peers;

  # maybe 409 if it already exists.
  my $paste = $c->param('paste') || '';
  my $id = Mojo::Util::sha1_sum(
            encode 'UTF-8',
            $paste
  );

  # looks bogus.
  return $c->render( json => {error => 'sha1 mismatch' }, status => 400 )
        if $c->stash('paste_id') ne $id;

  $c->delay(
    sub { $c->read_paste($id => $paste, shift->begin) },
    sub {
      my ($delay, $err) = @_;
      die $err if $err;
      return $c->render( json => {ok => 'thanks'}, status => 201 )
    },
  );
  };

get '/:paste_id', sub {
  my $c = shift;
  my $format   = $c->stash('format') || '';
  my $paste_id = $c->stash('paste_id');

  my $image_path = File::Spec->catfile($paste_dir, $paste_id);
  my $info=Image::Info::image_info( $image_path ); # does blocking reads to get magic numbers.

  if ( app->defaults('enable_images') and not $format ) {
      # only hijack the requests to just-the-id requests if the blob is an image.
      return $c->render(
        paste => app->b( 
        sprintf '<img src="%s.%s" height="%s" width="%s">',
          $paste_id, $info->{file_ext},
          $info->{height},$info->{width}), 
        ) if not exists $info->{error};
  }

  return $c->render(json => $info) 
    if not exists $info->{error} and grep $_ eq $format, qw[txt json];
  # .json might make sense if filled with stat info for text pastes 
   

  if (app->defaults('enable_images') and grep $format eq $_, @image_extensions) {
      # .raw -> just text, .jpg -> blob. Perhaps cache it if $info is expensive
      # an attempt could be made to convert between the $format and the image type

      # use Image::Magick;
      # my $x = Image::Magick->new;
      # $x->Read("image.jpg");
      # $x->Clone
      # $x->Resize(geometry => '48x48'); # this one if fine, good quality
      # $x->Write(filename => "image1.jpg");
      # $x->Resize(geometry => '500x500'); # this one is created from image1.jpg so the quality is poor
      # $x->Write("image2.jpg");

      if ( exists $info->{error} ) {
          # if it's not an image, bail out
          app->log->info("Attempt to load", $paste_id, " as .", $format, ":", $info->{error});
          return $c->render(
            text => "Error parsing this paste as an image: ". $info->{error}, 
            format=> 'text',
            status => 500);
      } 

      my $content_disposition = 'inline' || 'attachment';
      my $status              = 200;

      my $content_type = $info->{file_media_type}; 
      unless (grep $content_type eq $_, @allowed_image_types){
          app->log->info( "Refusing to serve", $paste_id, " as ", $content_type );
          $c->render(
            text => "Nope, not serving a $content_type", 
            format=> 'text',
            status => 500 );
      }

      # just like Mojolicious::Plugin::RenderFile
      my $headers = Mojo::Headers->new();
         $headers->add( 'Content-Type', $content_type . ';name=' . $paste_id );
         $headers->add( 'Content-Disposition', $content_disposition . ';filename=' . $paste_id ); # possibly reflected download

      my $asset = Mojo::Asset::File->new( path => $image_path );
         $headers->add( 'Content-Length' => $asset->size );

        $c->res->content->headers($headers);     
        $c->res->content->asset($asset);

        return $c->rendered($status);
  }

  $c->delay(
    sub { $c->read_paste($paste_id, shift->begin) },
    sub {
      my ($delay, $err, $paste) = @_;
      if ($err or !$paste) {
        return $c->reply->not_found 
      }
      elsif ($c->param('raw') or $format eq 'txt') {
        $c->res->headers->content_type('text/plain; charset=utf-8');
        $c->render(text => $paste);
      }
      else {
        $c->res->headers->header('X-Plain-Text-URL' => $c->url_for(format => 'txt')->userinfo(undef)->to_abs);
        $c->stash(embed => $c->param('embed')) if $c->param('embed');
        $c->render(paste => $paste);
      }
    },
  );
}, 'show';

get '/:paste_id/chart' => sub {
  my $c = shift;
  my $chart = {element => 'chart', data => [], hideHover => true, resize => true};
  my ($heading, $description, $error) = ('', '', '');

  $c->delay(
    sub { $c->read_paste($c->stash('paste_id'), shift->begin) },
    sub {
      my ($delay, $err, $paste) = @_;
      return $c->reply->not_found if $err or !$paste;

      while ($paste =~ s!^\s*(?://|\#)(.*)!!m) {
        $description .= $1 if $heading;
        $heading ||= $1;
      }

      eval {
        _chart($chart, grep { $_ =~ /\S/ } split /\r?\n/, $paste);
      } or do {
        $error = $@ || 'Unknown error';
        $error =~ s!\s*at .*? line \d+.*!!s;
      };

      $c->stash(embed => $c->param('embed')) if $c->param('embed');
      $c->render(chart => $chart, description => $description // '', error => $error, heading => $heading);
    }
  );
  }, 'chart' if app->defaults('enable_charts');

app->start;

sub _chart {
  eval 'require Text::CSV;1' or die 'Run "cpanm Text::CSV" to install missing dependency.';

  my $chart = shift;
  my $csv   = Text::CSV->new;

  $csv->parse(shift @_);    # heading
  $chart->{ykeys}  = [$csv->fields];
  $chart->{xkey}   = shift @{$chart->{ykeys}};
  $chart->{labels} = $chart->{ykeys};

  while (@_) {
    die $csv->error_input unless $csv->parse(shift @_);
    my @row = $csv->fields or next;
    push @{$chart->{data}}, {$chart->{xkey} => shift(@row), map { ($_ => 0 + shift @row) } @{$chart->{ykeys}}};
  }

  die 'Could not parse CSV data.' unless @{$chart->{data}};
  return $chart;
}

__DATA__
@@ css/mojopaste.css
  html, body, form, text { padding: 0; margin: 0; }
  body.has-nav { margin-top: 38px; }
  body, textarea { background: #f8f8f8; }
  body, textarea, a, .btn { color: #555; font-size: 16px; font-family: 'Helvetica Neue', Helvetica, sans-serif; }
  h2 { font-size: 1.5em; }
  h2, p { margin: 20px; }
  body.has-nav h2 { padding-top: 20px; }
  nav, .btn { background: #e6e6e6; border: 0 solid #ddd }
  nav { border-bottom-width: 1px; padding: 0 10px; overflow: hidden; position: fixed; top: 0; left: 0; right: 0; z-index: 100; }
  textarea, pre, .prettyprint { font-family:Menlo,Bitstream Vera Sans Mono,DejaVu Sans Mono,Monaco,Consolas,monospace; border:0!important, box-sizing: border-box; margin: 0; }
  body.has-nav textarea, body.has-nav pre { padding: 20px; }
  textarea { width: 100%; height: 100%; border: 0; outline-offset: 0; outline: 0; display: block; }
  pre { margin-bottom: 60px; }
  .top { background: #ddd; font-size: 14px; line-height: 1.5; text-decoration: none; text-align: center; padding: 7px 12px; margin-right: 3px; vertical-align: middle; display: block; float: left; cursor: pointer; }
  .btn { background: #ddd; font-size: 14px; line-height: 1.5; text-decoration: none; text-align: center; padding: 7px 12px; margin-right: 3px; vertical-align: middle; display: block; float: left; cursor: pointer; }
  .btn:hover { background: #d0d0d0; }
  .btn:focus { background: #ccc; outline: 0; }
  .powered-by { float: right; display: block; }

@@ css/prettify-theme.css
  /*! Color themes for Google Code Prettify | MIT License | github.com/jmblog/color-themes-for-google-code-prettify */
  .pln{color:#555}ol.linenums{margin-top:0;margin-bottom:0;color:#ccc}li.L0,li.L1,li.L2,li.L3,li.L4,li.L5,li.L6,li.L7,li.L8,li.L9{padding-left:1em;list-style-type:decimal}
  @media screen{.str{color:#183691}.kwd{color:#a71d5d}.com{color:#969896}.typ{color:#0086b3}.lit{color:#0086b3}.pun{color:#333}.opn{color:#333}.clo{color:#333}.tag{color:navy}.atn{color:#795da3}.atv{color:#183691}.dec{color:#333}.var{color:teal}.fun{color:#900}}


@@ layouts/mojopaste.html.ep
<!DOCTYPE>
<html>
<head>
  <title><%= title %></title>
  <meta name="description" content="A Mojolicious powered pastebin">
  <meta name="viewport" content="width=device-width, initial-scale=0.9" />

  %= stylesheet '//cdnjs.cloudflare.com/ajax/libs/morris.js/0.5.1/morris.css' if stash 'chart';
  %= stylesheet '/css/prettify-theme.css'
  %= stylesheet '/css/mojopaste.css'
  %= javascript begin
  window.onkeydown = function(e) {
    var el;
    if (!e.ctrlKey && !e.metaKey) return; // ctrl or cmd
    if (e.keyCode != 65 && e.keyCode != 97) return; // A or a
    if (el = document.querySelector(".prettyprint")) {
      var range = document.createRange();
      range.selectNodeContents(el);
      var selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      e.preventDefault();
    }
    else if(el = document.querySelector("textarea")) {
      el.select();
      e.preventDefault();
    }
  };
  window.onload = function(e) {
    var form = document.querySelector('form');
    var pre = document.querySelector('pre');

    if (form) {
      document.querySelector('textarea').focus();
      document.querySelector('.save.btn').onclick = function(e) {
            form.action = '<%= url_for 'pastebin' %>' };
    }
    if (pre && pre.firstChild.nodeValue.length < 50000) {
      prettyPrint();
    }
  };
  % end

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

</head>

<body class="<%= $embed =~ /nav/ ? 'has-nav' : '' %>">
% if ($embed =~ /nav/) { # New,Edit,Raw,Graph  ; Chart: New,Edit,Data
<nav>
  %= link_to 'New', 'pastebin',                                                class => 'btn'
  % if(my $paste_id = stash 'paste_id') {
  %= link_to 'Edit',  url_for('pastebin')->query(edit => $paste_id),           class => 'btn'
  % if (stash 'chart') { 
  %= link_to 'Data',  url_for('show', paste_id => $paste_id ),                 class => 'btn'
  % } else { # It'd be nice to not offer a chart for an image:
  %= link_to 'Graph', url_for('chart'),                                        class => 'btn' if $enable_charts
  % }
  %= link_to 'Raw',   url_for('show', paste_id => $paste_id, format => 'txt'), class => 'btn'
  % }

  %= include 'powered_by'
</nav>
% }
  %= content
</body>
</html>
@@ layouts/mojopaste.txt.ep
%= content
@@ pastebin.html.ep
%= form_for 'invalid', method => 'post', (enctype => 'multipart/form-data') => begin
<nav>
  <button class="save btn" tabindex="2">Save</button>
% if ($enable_images) {
  <input  class="save btn" type=file name=image_upload>
% }
% if ($enable_fetching) {
  <div class=top><label><input type=checkbox name=body_is_url>Fetch content from url:</label></div>
% }
  %= include 'powered_by'
</nav>
%= text_area 'paste', placeholder => $placeholder, tabindex => 1
% end
@@ chart.html.ep
% if ($heading and $embed =~ /heading/) {
<h2><%= $heading %></h2>
% }
% if ($description and $embed =~ /description/) {
<p><%= $description %></p>
% }
% if ($embed =~ /graph/) {
<div id="chart"><%= $error %></div>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/morris.js/0.5.1/morris.min.js"></script>
  % unless ($error) {
<script>
try {
  var chart = document.getElementById('chart');
  var tid, resize = function() { chart.style.height = (window.innerHeight - chart.offsetTop) + 'px' };
  resize();
  window.onresize = function() { if (tid) clearTimeout(tid); var tid = setTimeout(resize, 10); }
  new Morris.Line(<%== Mojo::JSON::encode_json(stash 'chart') %>);
} catch(e) {
  document.getElementById('chart').innerHTML = 'Invalid chart data. ' + e;
}
</script>
  % }
% }
@@ show.html.ep
<pre class="prettyprint linenums"><%= $error || $paste %></pre>
@@ powered_by.html.ep
<a class="btn powered-by" href="<%= $source_url %>" title="Get mojopaste"><%= $source_title %></a>
@@ show.txt.ep
Paste not found: <%= $paste_id %>
@@ not_found.html.ep
<b>Not Found.</b>
@@ not_found.txt.ep
Not found.
